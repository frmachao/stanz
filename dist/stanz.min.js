/*!
* stanz v7.0.0
* https://github.com/kirakiray/stanz
* 
* (c) 2018-2021 YAO
* Released under the MIT License.
*/((e,t)=>{"use strict";"object"==typeof exports?module.exports=t():"function"==typeof define&&define.amd?define(t):e.stanz=t()})(this,()=>{"use strict";const e=()=>Math.random().toString(32).substr(2);var t=Object.prototype.toString,r=e=>t.call(e).toLowerCase().replace(/(\[object )|(])/g,"");const s=Object.defineProperties,o=Object.getOwnPropertyDescriptor,n=e=>e instanceof w,i=null!==document.currentScript.getAttribute("debug"),a=(()=>{if(i){let t=new Map;return(r,s)=>{s||(s=e());let o=t.get(s);clearTimeout(o),t.set(s,setTimeout(()=>{r(),t.delete(s)}))}}let t=new Map,r=e=>Promise.resolve().then(()=>e());"object"==typeof process&&process.nextTick&&(r=process.nextTick);let s=!1;return(o,n)=>{n||(n=e()),t.set(n,{key:n,fun:o}),s||(s=!0,r(()=>{t.size&&t.forEach(({key:e,fun:r})=>{try{r()}catch(e){console.error(e)}t.delete(e)}),t.clear(),s=!1}))}})(),c=(e,t)=>{let r,s=[];const o=n=>{s.push(Object.assign({},n)),t?(clearTimeout(r),r=setTimeout(()=>{e(s),s.length=0},t)):a(()=>{e(s),s.length=0},o)};return o},l=(e,t,r={})=>{Object.keys(t).forEach(s=>{let{get:n,set:i,value:a}=o(t,s);a?e.hasOwnProperty(s)?e[s]=a:Object.defineProperty(e,s,{...r,value:a}):Object.defineProperty(e,s,{...r,get:n,set:i})})},h=(Date.now(),Symbol("self")),u=Symbol("proxy"),p=Symbol("watchs"),f=Symbol("can_update"),y=new Set(["root","sub","revoke"]),d=(e,t,r,s)=>{let o;o=t.path=r?[e[u],...r]:[e[u]],e[p].forEach(e=>e(t)),s||e._unupdate||e.owner&&e.owner.forEach(e=>d(e,t,o.slice()))};class w{constructor(t,r){let n;t.get?(n=new Proxy(this,{get:t.get,ownKeys:t.ownKeys,getOwnPropertyDescriptor:t.getOwnPropertyDescriptor,set:b.set}),delete t.get,delete t.ownKeys,delete t.getOwnPropertyDescriptor):n=new Proxy(this,b);let i=r;s(this,{[h]:{value:this},[u]:{value:n},xid:{value:"x_"+e()},_xtatus:{get:()=>i,set(e){if(!y.has(e))throw{target:n,desc:`xtatus not allowed to be set ${e}`};const t=this.owner.size;if("revoke"===e&&t)throw{target:n,desc:"the owner is not empty"};if("revoke"===i&&"revoke"!==e)t||v(this);else if("sub"===i&&"root"===e)throw{target:n,desc:"cannot modify sub to root"};i=e}},owner:{configurable:!0,writable:!0,value:new Set},length:{configurable:!0,writable:!0,value:0},[p]:{value:new Map},[f]:{writable:!0,value:0}});let a=-1;return Object.keys(t).forEach(e=>{let r=o(t,e),{value:i,get:c,set:l}=r;"get"!==e&&(/\D/.test(e)||(e=parseInt(e))>a&&(a=e),c||l?s(this,{[e]:r}):n[e]=i)}),a>-1&&(this.length=a+1),this[f]=1,n}watch(t){const r="e_"+e();return this[p].set(r,t),r}unwatch(e){return this[p].delete(e)}setData(e,t){let s=r(t);"array"!=s&&"object"!=s||(t=x(t,"sub")).owner.add(this);const o=this[e];if(o===t)return!0;let n=Reflect.set(this,e,t);return this[f]&&d(this,{xid:this.xid,name:"setData",args:[e,t]}),g(o,this),n}delete(e){if(/^_/.test(e)||"symbol"==typeof e)return Reflect.deleteProperty(this,e);if(!e)return!1;const t=this[h];let r=t[e];g(r,t);let s=Reflect.deleteProperty(t,e);return d(this,{xid:this.xid,name:"delete",args:[e]}),s}}const b={set(e,t,r,o){if("symbol"==typeof t)return Reflect.set(e,t,r,o);if(/^_/.test(t))return e.hasOwnProperty(t)?Reflect.set(e,t,r,o):s(e,{[t]:{writable:!0,configurable:!0,value:r}}),!0;try{return e.setData(t,r)}catch(e){throw{desc:`failed to set ${t}`,key:t,value:r,target:o}}},deleteProperty:function(e,t){return e.delete(t)}},g=(e,t)=>{if(!n(e))return;const{owner:r}=e;r.delete(t),r.size||(e._xtatus="revoke",Object.values(e).forEach(t=>{g(t,e[h])}))},v=e=>{"revoke"===e._xtatus&&Object.values(e).forEach(t=>{n(t)&&(v(t),t.owner.add(e),t._xtatus="sub")})},x=(e,t="root")=>n(e)?(e._xtatus=t,e):new w(e,t);l(w.prototype,{seek(e){let t=[];if(!(e=>r(e).search("function")>-1)(e)){let t=new Function(`with(this){return ${e}}`);e=(e=>{try{return t.call(e,e)}catch(e){}})}return e.call(this,this)&&t.push(this),Object.values(this).forEach(r=>{n(r)&&t.push(...r.seek(e))}),t},watchTick(e,t){return this.watch(c(e,t))},watchUntil(e){if(/[^=><]=[^=]/.test(e))throw"cannot use single =";return new Promise(t=>{let r,s=new Function(`\n        try{with(this){\n            return ${e}\n        }}catch(e){}`).bind(this);const o=this.watch(r=(()=>{let e=s();e&&(this.unwatch(o),t(e))}));r()})},watchKey(e,t){t&&Object.keys(e).forEach(t=>e[t].call(this,this[t]));let r={};return Object.entries(this).forEach(([e,t])=>{r[e]=t}),this.watch(c(t=>{Object.keys(e).forEach(s=>{let o=this[s];if(r[s]!==o)e[s].call(this,o);else if(n(o)){t.some(e=>{return e.path[1]==o})&&e[s].call(this,o)}r[s]=o})}))},toJSON(){let e={},t=!0,r=0;Object.keys(this).forEach(s=>{let o=this[s];/\D/.test(s)?t=!1:(s=parseInt(s))>r&&(r=s),n(o)&&(o=o.toJSON()),e[s]=o}),t&&(e.length=r+1,e=Array.from(e));const o=this.xid;return s(e,{xid:{get:()=>o}}),e},toString(){return JSON.stringify(this.toJSON())}}),["concat","every","filter","find","findIndex","forEach","map","slice","some","indexOf","lastIndexOf","includes","join"].forEach(e=>{let t=Array.prototype[e];t&&s(w.prototype,{[e]:{value:t}})});const m=Array.prototype.splice;l(w.prototype,{splice(e,t,...s){let o=this[h];s=s.map(e=>{let t=r(e);return"array"!=t&&"object"!=t||(e=x(e,"sub")).owner.add(o),e});let n="number"==r(t)?t:this.length-e,i=m.call(o,e,n,...s);return i.forEach(e=>g(e,o)),d(this,{xid:this.xid,name:"splice",args:[e,t,...s]}),i},unshift(...e){return this.splice(0,0,...e),this.length},push(...e){return this.splice(this.length,0,...e),this.length},shift(){return this.splice(0,1)[0]},pop(){return this.splice(this.length-1,1)[0]}}),["sort","reverse"].forEach(e=>{const t=Array.prototype[e];t&&s(w.prototype,{[e]:{value(...r){let s=t.apply(this[h],r);return d(this,{xid:this.xid,name:e}),s}}})});const O=e=>x(e,"root");return Object.assign(O,{version:"7.0.0",v:7e6,isxdata:n}),O});