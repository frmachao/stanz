/*!
* stanz v6.2.1
* https://github.com/kirakiray/stanz
* 
* (c) 2018-2021 YAO
* Released under the MIT License.
*/((e,t)=>{"use strict";"object"==typeof exports?module.exports=t():"function"==typeof define&&define.amd?define(t):e.stanz=t()})(this,()=>{"use strict";const e=()=>Math.random().toString(32).substr(2);let t=Object.prototype.toString;const s=e=>t.call(e).toLowerCase().replace(/(\[object )|(])/g,""),r=e=>void 0===e,n=e=>s(e).includes("function"),a=e=>e instanceof P?e.object:JSON.parse(JSON.stringify(e)),i=(()=>{if(null!==document.currentScript.getAttribute("debug")){let t=new Map;return(s,r)=>{r||(r=e());let n=t.get(r);clearTimeout(n),t.set(r,setTimeout(()=>{s(),t.delete(r)}))}}let t=new Map,s=e=>Promise.resolve().then(()=>e());"object"==typeof process&&process.nextTick&&(s=process.nextTick);let r=!1;return(n,a)=>{a||(a=e()),t.set(a,{key:a,fun:n}),r||(r=!0,s(()=>{t.size&&t.forEach(({key:e,fun:s})=>{try{s()}catch(e){console.error(e)}t.delete(e)}),t.clear(),r=!1}))}})(),l=(t,s,r,n,i)=>{let l;l=t._modifyId?t._modifyId:e(),I(t,D).push(l),h(t);let c=new m({type:"update",target:t[v]||t});Object.defineProperties(c,{trend:{get:()=>new T(c)}}),n&&Object.assign(c,n),c.modify={name:s,args:r.map(e=>e instanceof P?e.object:e instanceof Object?a(e):e),mid:l},i&&i(c),t.emit(c)};let c,o=new Set;const h=e=>{e[D].length<50||(clearTimeout(c),o.add(e),c=setTimeout(()=>{let e=Array.from(o);setTimeout(()=>{e.forEach(e=>h(e))},1e3),o.forEach(e=>{let t=e[D];t.splice(0,Math.ceil(t.length/2))}),o.clear()},3e3))},f=e=>{if(e instanceof H)return void(e=>{e.index=void 0,e.parent=void 0,e[V].mirrorHost.off("update",e[A]),e[V].mirrorHost=void 0})(e);if(!(e instanceof P))return;let t=e[O];if(t)try{t.index=void 0,t.parent=void 0}catch(e){}if(e instanceof C){let{mappingXData:s}=e,r=s[S].find(e=>e.data===t),{leftUpdate:n,rightUpdate:a}=r;e.off("update",a),s.off("update",n),t.mappingXData=null}if(t[E])for(let[s,r]of t[E])e.unsync(s);t[S]&&(t[S].forEach(e=>{let{data:s,leftUpdate:r,rightUpdate:n}=e;s.off("update",n),t.off("update",r),s.mappingXData=null}),t[S].splice(0)),t.emit("clearxdata"),t[k]&&t[k].clear(),t[p]&&t[p].clear()},d=(e,t)=>{if(e instanceof H)return e;let r=e;switch(s(e)){case"object":case"array":r=new P(e,t)}return r},u=(e,t)=>{if(e instanceof Array)return e.map(e=>u(e,t));if(e instanceof Object){let s={},r=[];return Object.keys(e).forEach(n=>{/\D/.test(n)?s[n]=u(e[n]):r.push(u(e[n],t))}),r.length&&(s[t]=r),s}return e},p=Symbol("events"),b=(e,t)=>{let s=t[p];s||(s=new Map,Object.defineProperty(t,p,{value:s}));let r=s.get(e);return r||(r=[],s.set(e,r)),r},y=(e,t)=>{let s;return e instanceof m?e=(s=e).type:s=new m({type:e,target:t[v]||t}),s};class g{constructor(e={}){Object.defineProperties(this,{parent:{writable:!0,value:e.parent,configurable:!0},index:{writable:!0,value:e.index,configurable:!0}})}on(e,t,s){this.addListener({type:e,data:s,callback:t})}one(e,t,s){this.addListener({count:1,type:e,data:s,callback:t})}addListener(e={}){let{type:t,data:s,callback:n,count:a=1/0,eventId:i}=e;if(!t)throw{desc:"addListener no type",options:e};let l=t.split("#");1 in l&&(t=l[0],i=l[1]);let c=b(t,this);r(i)||Array.from(c).some(e=>{if(e.eventId===i){let t=c.indexOf(e);return t>-1&&c.splice(t,1),!0}}),n&&c.push({type:t,data:s,callback:n,eventId:i,count:a})}off(e,t){if(e){if(!t)throw{desc:"off must have callback"};{let s=b(e,this),r=s.findIndex(e=>e.callback==t);r>-1&&s.splice(r,1)}}}emitHandler(e,t){let s=y(e,this);e=s.type;let r=b(e,this),n=[];return s.currentTarget=this[v]||this,r.some(e=>{e.data&&(s.data=e.data),e.eventId&&(s.eventId=e.eventId);let r={self:this,event:s,emitData:t};if((e.before?e.before(r):1)&&e.callback.call(this[v]||this,s,t),e.after&&e.after(r),delete s.data,delete s.eventId,e.count--,e.count||n.push(e),s.cancel)return!0}),delete s.currentTarget,n.forEach(e=>{let t=r.indexOf(e);t>-1&&r.splice(t,1)}),s}emit(e,t){let s=this.emitHandler(e,t);if(s.bubble&&!s.cancel){let{parent:e}=this;e&&(s.keys.unshift(this.index),e.emit(s,t))}}}class m extends g{constructor(e){super(),this.type=e.type,this.target=e.target,this._bubble=!0,this._cancel=!1,this.keys=[]}get bubble(){return this._bubble}set bubble(e){this._bubble!==e&&(this.emitHandler("set-bubble",e),this._bubble=e)}get cancel(){return this._cancel}set cancel(e){this._cancel!==e&&(this.emitHandler("set-cancel",e),this._cancel=e)}}const w=/^_.+|^index$|^length$|^object$|^getData$|^setData$/,j=/^parent$|^index$|^length$|^object$/;let x={get:(e,t,s)=>"symbol"==typeof t||w.test(t)?Reflect.get(e,t,s):e.getData(t),set:(e,t,s,r)=>"symbol"==typeof t?Reflect.set(e,t,s,r):e.setData(t,s)};const v=Symbol("proxyThis"),O=Symbol("XDataSelf"),k=Symbol("WatchHost"),D=Symbol("ModifyIDS"),E=Symbol("SyncHost"),S=Symbol("VirDataHost"),_=Symbol("StanzID"),I=(e,t)=>{let s=e[t];if(!s){switch(t){case k:case E:s=new Map;break;case D:case S:s=[]}Object.defineProperty(e,t,{value:s})}return s},K="undefined"!=typeof Element;class P extends g{constructor(t,s={}){super(s);let r=new Proxy(this,x),n=0,a=Object.getOwnPropertyDescriptors(t);Object.keys(a).forEach(e=>{let{value:t,get:s,set:r}=a[e];s||r?Object.defineProperty(this,e,{configurable:!0,enumerable:!0,get:s,set:r}):/^\_/.test(e)||K&&t instanceof Element?Object.defineProperty(this,e,{configurable:!0,writable:!0,value:t}):(/\D/.test(e)||(e=parseInt(e))>=n&&(n=e+1),t instanceof H?(this[e]=t,t.parent=this,t.index=e):t instanceof Object?this[e]=new P(t,{parent:this,index:e}):this[e]=t)});const i=e();Object.defineProperties(this,{[O]:{get:()=>this},[v]:{value:r},[_]:{value:i},xid:{get:()=>i},_modifyId:{value:null,writable:!0},length:{configurable:!0,writable:!0,value:n}})}setData(e,t){if(j.test(e))return console.warn("you can't set this key in XData => ",e),!1;if(/^_.+/.test(e))return Object.defineProperty(this,e,{configurable:!0,writable:!0,value:t}),!0;let r=this[O];if(/\./.test(e)){let s=e.split("."),n=s.length-1;return s.some((t,s)=>{if(s==n)return e=t,!0;r=r[t]}),r.setData(e,t),!0}let n=s(e);if("string"===n||"number"===n){let s=r[e];return t===s||(s instanceof P&&(s=s.object),t instanceof H?(t.parent&&t.remove(),t.parent=r,t.index=e):t instanceof P?(t[O]&&(t=t[O]),t.parent&&t.remove(),t.parent=r,t.index=e):t instanceof Object&&(t=d(t,{parent:r,index:e})),r[e]=t,l(r,"setData",[e,t],{oldValue:s}),!0)}if(e instanceof Object){let t=e;return Object.keys(t).forEach(e=>{let s=t[e];r.setData(e,s)}),!0}}getData(e){let t;if(e.includes&&e.includes(".")){let s=e.split(".");t=this;do{t=t[s.shift()]}while(s.length)}else t=this[e];return t instanceof P&&(t=t[v]),t}remove(e){if(r(e)){let{parent:e}=this;e?e.remove(this.index):f(this)}else{let t=this[e];/\D/.test(e)?(delete this[e],f(t),l(this,"remove",[e])):this.splice(parseInt(e),1)}}deepClear(){Object.keys(this).forEach(e=>{if(/\D/.test(e)){let t=this[e];t instanceof P&&t.deepClear(),t instanceof H&&f(t)}}),this.forEach(e=>{e instanceof P&&e.deepClear(),e instanceof H&&f(e)}),f(this)}add(e){!this.includes(e)&&this.push(e)}delete(e){let t=this.indexOf(e);t>-1&&this.splice(t,1)}has(e){return this.includes(e)}clear(){this.splice(0,this.length)}before(e){if(/\D/.test(this.index))throw{text:"It must be an array element",target:this,index:this.index};return this.parent.splice(this.index,0,e),this}after(e){if(/\D/.test(this.index))throw{text:"It must be an array element",target:this,index:this.index};return this.parent.splice(this.index+1,0,e),this}clone(){return d(a(this))[v]}emitHandler(e,t){let s=y(e,this);if("update"===s.type){let{_unBubble:e,_update:t,_unpush:r}=this,{fromKey:n}=s.trend;(!1===t||e&&e.includes(n))&&(s.bubble=!1),r&&r.includes(n)&&Object.defineProperty(s,"_unpush",{value:!0})}return g.prototype.emitHandler.call(this,s,t),s}noStanz(e={childKey:"children"}){return u(this.object,e.childKey)}get object(){let e={},t=!0,{_unBubble:s=[]}=this;return Object.keys(this).forEach(r=>{if(/^_/.test(r)||!/\D/.test(r)||s.includes(r)||"length"===r)return;let n=this[r];if(n instanceof P||n instanceof H){if(!1===n._update)return;n=n.object}e[r]=n,t=!1}),this.forEach((t,s)=>{(t instanceof P||t instanceof H)&&(t=t.object),e[s]=t}),t&&(e.length=this.length,e=Array.from(e)),e}get string(){return JSON.stringify(this.object)}toJSON(){return JSON.stringify(this.object)}get root(){let e=this;for(;e.parent;)e=e.parent;return e}get prev(){if(!/\D/.test(this.index)&&this.index>0)return this.parent.getData(this.index-1)}get next(){if(!/\D/.test(this.index))return this.parent.getData(this.index+1)}get mirror(){return new H(this)}getTarget(e){let t=this;return e.length&&e.some(e=>{if(!t)return console.warn("getTarget failure"),!0;t=t[e]}),t}watch(e,t,r){let n,a=s(e);if("object"===a)return void Object.keys(e).forEach(s=>{this.watch(s,e[s],t)});/function/.test(a)&&(r=t,t=e,e=""),n=""===e?"watchSelf":e instanceof RegExp?"watchKeyReg":/\./.test(e)?"watchPointKey":"watchKey";let l=I(this,k).get(e);l||(l=new Set,I(this,k).set(e,l));let c,o={trends:[],callback:t,expr:e,push(e){this.trends.push(e)}};l.add(o);let h=this[v];switch(n){case"watchSelf":c=(e=>{o.push(e.trend),i(()=>{t.call(h,{trends:Array.from(o.trends)},h),o.trends.length=0},o)}),!0===r&&t.call(h,{trends:[]},h);break;case"watchKey":case"watchKeyReg":c=(s=>{let{trend:r}=s;("watchKeyReg"===n&&e.test(r.fromKey)||r.fromKey==e)&&(o.push(s.trend),o.cacheOld||(o._oldVal=s.oldValue instanceof P?s.oldValue.object:s.oldValue,o.cacheOld=!0),i(()=>{let s=this[e];t.call(h,{expr:e,val:s,old:o._oldVal,trends:Array.from(o.trends)},s),o.trends.length=0,o._oldVal=o.cacheOld=!1},o))}),!0===r&&t.call(h,{expr:e,val:h[e],trends:[]},h[e]);break;case"watchPointKey":let s=e.split("."),a=this.getTarget(s);a=a instanceof P?a.object:a,c=(r=>{let{trend:n}=r,l=n.keys.slice();if(l.length<s.length&&l.push(n.finalSetterKey),JSON.stringify(s)===JSON.stringify(l.slice(0,s.length))){let l;try{l=this.getTarget(s)}catch(r){}l!==a&&(o.push(n),i(()=>{(l=this.getTarget(s))!==a&&t.call(h,{expr:e,old:a,trends:Array.from(o.trends)},l),o.trends.length=0},o))}}),!0===r&&t.call(h,{expr:e,val:a},a)}return this.on("update",c),o.updateMethod=c,this}unwatch(e,t){let r=s(e);if("object"===r)return Object.keys(e).forEach(t=>{this.unwatch(t,e[t])}),this;/function/.test(r)&&(t=e,e="");let n=I(this,k).get(e);if(n){let s=Array.from(n).find(s=>s.callback===t&&s.expr===e);s&&(s.updateMethod&&this.off("update",s.updateMethod),n.delete(s),!n.size&&I(this,k).delete(e))}return this}watchUntil(e){if(/[^=]=[^=]/.test(e))throw"cannot use single =";return new Promise(t=>{let s,r=new Function(`\n            try{with(this){\n                return ${e}\n            }}catch(e){}`).bind(this);this.watch(s=(()=>{let e=r();e&&(this.unwatch(s),t(e))}),!0)})}entrend(e){let{mid:t,keys:s,name:r,args:n,_unpush:a}=e;if(a)return;let{_unpull:i}=this,l=M(e);if(i&&i.includes(l))return;if(!t)throw{text:"Illegal trend data"};let c=this.getTarget(s);if(c){let e=c[O];if(I(e,D).includes(t))return!1;e._modifyId=t,e[r](...n),e._modifyId=null}return!0}}const M=e=>{let t=e.keys[0];return!r(t)||"setData"!==e.name&&"remove"!==e.name||(t=e.args[0]),t};class T{constructor(e){if(e instanceof m){let{modify:{name:t,args:s,mid:r},keys:n}=a(e),{_unpush:i}=e;i&&Object.defineProperty(this,"_unpush",{value:!0}),Object.assign(this,{name:t,args:s,mid:r,keys:n})}else Object.assign(this,e)}get string(){return JSON.stringify(this)}get finalSetterKey(){switch(this.name){case"remove":case"setData":return this.args[0]}}get fromKey(){return M(this)}set fromKey(e){let t=this.keys[0];r(t)?"setData"!==this.name&&"remove"!==this.name||(this.args[0]=e):this.keys[0]=e}}class H{constructor(e){this[V]=this,this.mirrorHost=e,this.parent=void 0,this.index=void 0;let t=e=>{this.parent&&l(this.parent,"",[],{},t=>{Object.assign(t,{keys:a(e.keys),modify:a(e.modify),currentTarget:e.currentTarget,target:e.target,oldValue:e.oldValue}),t.keys.unshift(this.index)})};return e.on("update",t),this[A]=t,new Proxy(this,J)}remove(e){return P.prototype.remove.call(this,e)}}const A=Symbol("XMirrorUpdataBinder"),V=Symbol("XMirror_self"),$=new Set(["index","parent","remove",A,V]),J={get(e,t,s){if($.has(t))return e[t];let r=e.mirrorHost[t];return n(r)&&(r=r.bind(e.mirrorHost)),r},set:(e,t,s,r)=>$.has(t)?(e[t]=s,!0):e.mirrorHost.setData(t,s)},N=(e,t,s)=>{t.trends.forEach(t=>{t.fromKey===e&&s.entrend(t)})},U=(e,t,s)=>{t.trends.forEach(t=>{e.includes(t.fromKey)&&s.entrend(t)})},X=(e,t,s)=>{a(t.trends).forEach(t=>{t=new T(t);let{fromKey:n}=t;if(!r(n)){let r=e.get(n);r&&(t.fromKey=r,s.entrend(t))}})},W=e=>(e instanceof P&&(e=e.object),e),R=(e,t,s)=>{Object.keys(e).forEach(r=>{let n=e[r];if(n instanceof Object){t[r]||(t.setData?t.setData(r,{}):t[r]={});let e=t[r];R(n,e,s)}else{let a=s([r,n],{self:e,target:t});if(a){let[e,s]=a;t[e]=s}}})},z=(e,t,s)=>{let{trend:n}=t;if(n){switch(n.name){case"setData":let e=n.args[1];if(e instanceof Object){let t={};R(e,t,s),n.args[1]=t}else r(e)||(n.args=s(n.args,{event:t}));break;default:n.args=n.args.map(e=>{let t=e;return e instanceof Object&&R(e,t={},s),t})}e.entrend(n)}},L={sync(e,t,r){let n,a;switch(s(t)){case"string":r&&e.setData(t,W(this[t])),n=(s=>N(t,s,e)),a=(e=>N(t,e,this));break;case"array":r&&t.forEach(t=>{e.setData(t,W(this[t]))}),n=(s=>U(t,s,e)),a=(e=>U(t,e,this));break;case"object":let i=new Map(Object.entries(t)),l=new Map(Object.entries(t).map(e=>e.reverse()));r&&Object.keys(t).forEach(s=>{e.setData(t[s],W(this[s]))}),n=(t=>X(i,t,e)),a=(e=>X(l,e,this));break;default:if(r){let t=this.object;Object.keys(t).forEach(s=>{e.setData(s,t[s])})}n=(t=>t.trends.forEach(t=>e.entrend(t))),a=(e=>e.trends.forEach(e=>this.entrend(e)))}this.watch(n),e.watch(a);let i=I(this,E);i.has(e)&&this.unsync(e),i.set(e,{selfWatch:n,oppWatch:a}),I(e,E).set(this,{selfWatch:a,oppWatch:n})},unsync(e){let t=I(this,E).get(e);if(t){let{selfWatch:s,oppWatch:r}=t;this.unwatch(s),e.unwatch(r),I(this,E).delete(e),I(e,E).delete(this)}},virData(e,t){let r,n,a=new C(this[O],{}),i=s(e),l=e;if("object"==i)if("mapKey"in l){let s=Object.entries(l.mapKey),r=new Map(s),n=new Map(s.map(e=>e.reverse()));e=(([e,t])=>r.has(e)?[r.get(e),t]:[e,t]),t=(([e,t])=>n.has(e)?[n.get(e),t]:[e,t])}else if("mapValue"in l){let s=l.key,r=Object.entries(l.mapValue),n=new Map(r),a=new Map(r.map(e=>e.reverse()));e=(([e,t])=>e===s&&n.has(t)?[e,n.get(t)]:[e,t]),t=(([e,t])=>e===s&&a.has(t)?[e,a.get(t)]:[e,t])}return R(this,a,e),this.on("update",r=(t=>z(a,t,e))),a.on("update",n=(e=>z(this,e,t))),I(this,S).push({data:a,leftUpdate:r,rightUpdate:n}),a[v]}};Object.keys(L).forEach(e=>{Object.defineProperty(P.prototype,e,{writable:!0,value:L[e]})});class C extends P{constructor(e,...t){super(...t),Object.defineProperty(this,"mappingXData",{writable:!0,value:e})}}["concat","every","filter","find","findIndex","forEach","map","slice","some","indexOf","lastIndexOf","includes","join"].forEach(e=>{let t=Array.prototype[e];t&&Object.defineProperty(P.prototype,e,{value(...e){return t.apply(this,e)}})});const B=(e,t,s)=>{(e instanceof P||e instanceof H)&&t!==s&&(e.index=t,e.emitHandler("updateIndex",{oldIndex:s,index:t}))};["pop","push","reverse","splice","shift","unshift"].forEach(e=>{let t=Array.prototype[e];t&&Object.defineProperty(P.prototype,e,{value(...s){let r=[],n=this[O],a=n.object;s.forEach(e=>{if(e instanceof P){let t=e[O];t.remove(),r.push(t)}else if(e instanceof H)e.parent=n,r.push(e);else{let t=d(e,{parent:n});r.push(t)}});let i=t.apply(n,r);switch(n.forEach((e,t)=>{let s=e.index;B(e,t,s)}),e){case"shift":case"pop":(i instanceof P||i instanceof H)&&f(i);break;case"splice":i.forEach(e=>{(e instanceof P||e instanceof H)&&f(e)})}return l(n,e,s,{oldValue:a}),i}})}),Object.defineProperties(P.prototype,{sort:{value(e){let t=[],s=this[O],r=s.object,a=Array.from(s);if(n(e)||!e){Array.prototype.sort.call(s,e),s.forEach((e,t)=>{let s=e.index;B(e,t,s)}),t=[a.map(e=>e.index)],a=null}else e instanceof Array&&(e.forEach((e,t)=>{let r=s[e]=a[t],n=r.index;B(r,e,n)}),t=[e]);return l(s,"sort",t,{oldValue:r}),this}}});let F=e=>d(e)[v];return F.version="6.2.1",F.v=6002001,F});