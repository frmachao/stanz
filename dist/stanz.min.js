/*!
* stanz v7.0.0
* https://github.com/kirakiray/stanz
* 
* (c) 2018-2021 YAO
* Released under the MIT License.
*/((e,t)=>{"use strict";"object"==typeof exports?module.exports=t():"function"==typeof define&&define.amd?define(t):e.stanz=t()})(this,()=>{"use strict";const e=()=>Math.random().toString(32).substr(2);var t=Object.prototype.toString,r=e=>t.call(e).toLowerCase().replace(/(\[object )|(])/g,"");const s=Object.defineProperties,o=Object.getOwnPropertyDescriptor,n=e=>e instanceof w,i=null!==document.currentScript.getAttribute("debug"),a=(()=>{if(i){let t=new Map;return(r,s)=>{s||(s=e());let o=t.get(s);clearTimeout(o),t.set(s,setTimeout(()=>{r(),t.delete(s)}))}}let t=new Map,r=e=>Promise.resolve().then(()=>e());"object"==typeof process&&process.nextTick&&(r=process.nextTick);let s=!1;return(o,n)=>{n||(n=e()),t.set(n,{key:n,fun:o}),s||(s=!0,r(()=>{t.size&&t.forEach(({key:e,fun:r})=>{try{r()}catch(e){console.error(e)}t.delete(e)}),t.clear(),s=!1}))}})(),l=e=>{let t=[];const r=s=>{t.push(s),a(()=>{e(t),t.length=0},r)};return r},c=(e,t)=>{Object.keys(t).forEach(r=>{let{get:s,set:n,value:i}=o(t,r);i?e.hasOwnProperty(r)?e[r]=i:Object.defineProperty(e,r,{value:i}):Object.defineProperty(e,r,{get:s,set:n})})},h=(Date.now(),Symbol("self")),u=Symbol("proxy"),p=Symbol("watchs"),f=Symbol("can_update"),y=new Set(["root","sub","revoke"]),d=(e,t,r)=>{let s;s=t.path=r?[e[u],...r]:[e[u]],e[p].forEach(e=>e(t)),e.owner&&e.owner.forEach(e=>d(e,t,s.slice()))};class w{constructor(t,r){let n;t.get?(n=new Proxy(this,{get:t.get,ownKeys:t.ownKeys,getOwnPropertyDescriptor:t.getOwnPropertyDescriptor,set:b.set}),delete t.get,delete t.ownKeys,delete t.getOwnPropertyDescriptor):n=new Proxy(this,b);let i=r;s(this,{[h]:{value:this},[u]:{value:n},xid:{value:"x_"+e()},_xtatus:{get:()=>i,set(e){if(!y.has(e))throw{target:n,desc:`xtatus not allowed to be set ${e}`};const t=this.owner.size;if("revoke"===e&&t)throw{target:n,desc:"the owner is not empty"};if("revoke"===i&&"revoke"!==e)t||x(this);else if("sub"===i&&"root"===e)throw{target:n,desc:"cannot modify sub to root"};i=e}},owner:{writable:!0,value:new Set},length:{configurable:!0,writable:!0,value:0},[p]:{value:new Map},[f]:{writable:!0,value:0}});let a=-1;return Object.keys(t).forEach(e=>{let r=o(t,e),{value:i,get:l,set:c}=r;"get"!==e&&(/\D/.test(e)||(e=parseInt(e))>a&&(a=e),l||c?s(this,{[e]:r}):n[e]=i)}),a>-1&&(this.length=a+1),this[f]=1,n}watch(t){const r="e_"+e();return this[p].set(r,t),r}unwatch(e){return this[p].delete(e)}setData(e,t){let s=r(t);"array"!=s&&"object"!=s||(t=v(t,"sub")).owner.add(this);const o=this[e];if(o===t)return!0;let n=Reflect.set(this,e,t);return this[f]&&d(this,{xid:this.xid,name:"setData",args:[e,t]}),g(o,this),n}delete(e){if(/^_/.test(e)||"symbol"==typeof e)return Reflect.deleteProperty(this,e);if(!e)return!1;const t=this[h];let r=t[e];g(r,t);let s=Reflect.deleteProperty(t,e);return d(this,{xid:this.xid,name:"delete",args:[e]}),s}}const b={set:(e,t,r,o)=>"symbol"==typeof t?Reflect.set(e,t,r,o):/^_/.test(t)?(e.hasOwnProperty(t)?Reflect.set(e,t,r,o):s(e,{[t]:{writable:!0,configurable:!0,value:r}}),!0):e.setData(t,r),deleteProperty:function(e,t){return e.delete(t)}},g=(e,t)=>{if(!n(e))return;const{owner:r}=e;r.delete(t),r.size||(e._xtatus="revoke",Object.values(e).forEach(t=>{g(t,e[h])}))},x=e=>{"revoke"===e._xtatus&&Object.values(e).forEach(t=>{n(t)&&(x(t),t.owner.add(e),t._xtatus="sub")})},v=(e,t="root")=>n(e)?(e._xtatus=t,e):new w(e,t);c(w.prototype,{seek(e){let t=[];if(!(e=>r(e).search("function")>-1)(e)){let t=new Function(`with(this){return ${e}}`);e=(e=>{try{return t.call(e,e)}catch(e){}})}return e.call(this,this)&&t.push(this),Object.values(this).forEach(r=>{n(r)&&t.push(...r.seek(e))}),t},watchTick(e){return this.watch(l(e))},watchUntil(e){if(/[^=]=[^=]/.test(e))throw"cannot use single =";return new Promise(t=>{let r=new Function(`\n        try{with(this){\n            return ${e}\n        }}catch(e){}`).bind(this);const s=this.watch(()=>{let e=r();e&&(this.unwatch(s),t(e))})})},watchKey(e){let t={};return this.watch(l(r=>{Object.keys(e).forEach(s=>{let o=this[s];if(t[s]!==o)e[s].call(this,o);else if(n(o)){r.some(e=>{if(e.path[1]==t[s])return!0})&&e[s].call(this,o)}t[s]=o})}))},toJSON(){let e={},t=!0,r=0;Object.keys(this).forEach(s=>{let o=this[s];/\D/.test(s)?t=!1:(s=parseInt(s))>r&&(r=s),n(o)&&(o=o.toJSON()),e[s]=o}),t&&(e.length=r+1,e=Array.from(e));const o=this.xid;return s(e,{xid:{get:()=>o}}),e},toString(){return JSON.stringify(this.toJSON())}}),["concat","every","filter","find","findIndex","forEach","map","slice","some","indexOf","lastIndexOf","includes","join"].forEach(e=>{let t=Array.prototype[e];t&&s(w.prototype,{[e]:{value:t}})});const m=Array.prototype.splice;c(w.prototype,{splice(e,t,...s){let o=this[h];s=s.map(e=>{let t=r(e);return"array"!=t&&"object"!=t||(e=v(e,"sub")).owner.add(o),e});let n=m.call(o,e,t,...s);return n.forEach(e=>g(e,o)),d(this,{xid:this.xid,name:"splice",args:[e,t,...s]}),n},unshift(...e){return this.splice(0,0,...e),this.length},push(...e){return this.splice(this.length,0,...e),this.length},shift(){return this.splice(0,1)[0]},pop(){return this.splice(this.length-1,1)[0]}}),["sort","reverse"].forEach(e=>{const t=Array.prototype[e];t&&s(w.prototype,{[e]:{value(...r){let s=t.apply(this[h],r);return d(this,{xid:this.xid,name:e}),s}}})});const O=e=>v(e,"root");return Object.assign(O,{version:"7.0.0",v:7e6,isxdata:n}),O});